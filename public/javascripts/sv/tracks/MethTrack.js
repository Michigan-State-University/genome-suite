/*
 * The reads track shows short reads generated by high-throughput sequencing.
 * The display is rendered at three levels, histogram, boxes and sequence
 * This is slightly different from the stacks track which collapses reads
 */
AnnoJ.MethTrack = function(userConfig)
{
	var self = this;

	AnnoJ.MethTrack.superclass.constructor.call(self, userConfig);	
	
	var defaultConfig = {
		single   : false,
		clsAbove : 'AJ_above',
		clsBelow : 'AJ_below'
	};
	Ext.applyIf(self.config, defaultConfig);
	
	//Initialize the DOM elements
	var containerA = new Ext.Element(document.createElement('DIV'));
	var containerB = new Ext.Element(document.createElement('DIV'));
	
	containerA.addCls(self.config.clsAbove);
	containerB.addCls(self.config.clsBelow);
	
	//Force some styles
	containerA.setStyle('position', 'relative');
	containerB.setStyle('position', 'relative');
	containerA.setStyle('width', '100%');
	containerB.setStyle('width', '100%');
		
	if (self.config.single)
	{
		containerA.setStyle('height', self.Canvas.ext.getHeight());
		containerB.setStyle('display', 'none');
	}
	else
	{
		containerA.setStyle('height', '49%');
		containerB.setStyle('height', '49%');
		containerA.setStyle('borderBottom', 'dotted black 1px');
	}
	containerA.appendTo(self.Canvas.ext);
	containerB.appendTo(self.Canvas.ext);
	
	//Create the menu checkboxes for controlling meth state
	var menuCG = new Ext.menu.CheckItem(
	{
		text    : 'CG',
		handler : toggleMeth
	});
	var menuCHG = new Ext.menu.CheckItem(
	{
		text    : 'CHG',
		handler : toggleMeth
	});
	var menuCHH = new Ext.menu.CheckItem(
	{
		text    : 'CHH',
		handler : toggleMeth
	});
	menuCG.setChecked(true);
	menuCHG.setChecked(true);
	menuCHH.setChecked(true);
	self.ContextMenu.addItems([menuCG,menuCHG,menuCHH]);
	
	//Create the toolbar buttons for controlling meth context
	var toolbarCG = new Ext.Toolbar.Button(
	{
		text    : 'CG',
		iconCls : 'silk_bullet_orange',
		tooltip : 'Show/hide CG methylation',
		handler : toggleMeth
	});
	var toolbarCHG = new Ext.Toolbar.Button(
	{
		text    : 'CHG',
		iconCls : 'silk_bullet_blue',
		tooltip : 'Show/hide CHG methylation',
		handler : toggleMeth
	});
	var toolbarCHH = new Ext.Toolbar.Button(
	{
		text    : 'CHH',
		iconCls : 'silk_bullet_pink',
		tooltip : 'Show/hide CHH methylation',
		handler : toggleMeth
	});
	self.Toolbar.insert(4,toolbarCHH);
	self.Toolbar.insert(4,toolbarCHG);
	self.Toolbar.insert(4,toolbarCG);
	
	
	//Toggle meth context visibility
	function toggleMeth(item)
	{
		var show = true;
		
		if (item.iconCls)
		{
			show = item.iconCls == 'silk_bullet_white';
		}
		else
		{
			show = !item.checked
		}
		
		if (item.text == 'CG')
		{
			toolbarCG.setIconClass(show ? 'silk_bullet_orange' : 'silk_bullet_white');
			if (item.iconCls) menuCG.setChecked(show);
		}
		else if (item.text == 'CHG')
		{
			toolbarCHG.setIconClass(show ? 'silk_bullet_blue' : 'silk_bullet_white');
			if (item.iconCls) menuCHG.setChecked(show);
		}
		else if (item.text == 'CHH')
		{
			toolbarCHH.setIconClass(show ? 'silk_bullet_pink' : 'silk_bullet_white');
			if (item.iconCls) menuCHH.setChecked(show);
		}
		else
		{
			return;
		}
		handler.canvasA.groups.toggle(item.text, show);
		handler.canvasB.groups.toggle(item.text, show);
		handler.canvasA.refresh();
		handler.canvasB.refresh();
	}
	
	
	//Histogram mode
	var Histogram = (function()
	{
		var dataA = new HistogramData();
		var dataB = new HistogramData();
				
		function parse(data)
		{
			dataA.parse(data,true);
			dataB.parse(data,false);
		};
		
		var canvasA = new HistogramCanvas();
		var canvasB = new HistogramCanvas();
		canvasB.flipY();
		
		canvasA.setContainer(containerA.dom);
		canvasB.setContainer(containerB.dom);

		function paint(left, right, bases, pixels)
		{
			var subsetA = dataA.subset2canvas(left, right, bases, pixels);
			var subsetB = dataB.subset2canvas(left, right, bases, pixels);

			canvasA.setData(subsetA);
			canvasB.setData(subsetB);

			var max = Math.max(canvasA.getMax() || 0, canvasB.getMax() || 0);
			canvasA.normalize(max);
			canvasB.normalize(max);
			
			canvasA.paint();
			canvasB.paint();
		};
		
		return {
			dataA : dataA,
			dataB : dataB,
			canvasA : canvasA,
			canvasB : canvasB,
			parse : parse,
			paint : paint
		};
	})();
		
	//Data handling and rendering object
	var handler = Histogram;
		
	//Zoom policies (dictate which handler to use)
	var policies = [
		{ index:0, min:1/100 , max:10/1   , bases:1   , pixels:1  , cache:10000    },
		{ index:1, min:10/1  , max:100/1  , bases:10  , pixels:1  , cache:100000   },
		{ index:2, min:100/1 , max:1000/1 , bases:100 , pixels:1  , cache:1000000  },
		{ index:3, min:1000/1, max:10000/1, bases:1000, pixels:1  , cache:10000000 }
	];
		
	this.getPolicy = function(view)
	{
		var ratio = view.bases / view.pixels;
		
		handler = Histogram;
		
		for (var i=0; i<policies.length; i++)
		{
			if (ratio >= policies[i].min && ratio < policies[i].max)
			{			
				return policies[i];
			}
		}
		return null;
	};
	this.rescale = function(f)
	{
		var f = Math.pow(f*2, 4);
		handler.canvasA.setScaler(f);
		handler.canvasB.setScaler(f);
		handler.canvasA.refresh();
		handler.canvasB.refresh();
	};	
	this.clearCanvas = function()
	{
		handler.canvasA.clear();
		handler.canvasB.clear();
	};
	this.paintCanvas = function(l,r,b,p)
	{
		handler.paint(l,r,b,p);
	};
	this.refreshCanvas = function()
	{
		handler.canvasA.refresh(true);
		handler.canvasB.refresh(true);
	};
	this.resizeCanvas = function()
	{
		handler.canvasA.refresh(true);
		handler.canvasB.refresh(true);
	};
	this.clearData = function()
	{
		handler.dataA.clear();
		handler.dataB.clear();
	};
	this.pruneData = function(a,b)
	{
		handler.dataA.prune(a,b);
		handler.dataB.prune(a,b);
	};
	this.parseData = function(data)
	{
		handler.parse(data);
	};
};
Ext.extend(AnnoJ.MethTrack,AnnoJ.BrowserTrack,{})
