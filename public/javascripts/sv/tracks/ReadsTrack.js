/*
 * The reads track shows short reads generated by high-throughput sequencing
 */
Ext.define("Sv.tracks.ReadsTrack",{
  extend : "Sv.tracks.BrowserTrack",
  //single    : false,
	clsAbove  : 'AJ_above',
	clsBelow  : 'AJ_below',
	color_above: '800000',
	color_below: '003300',
	//readSlider    : 0.60,
	scale  : 1.0,
	maxHeight : 5000,
	boxHeight : 12,
	boxHeightMax : 24,
	boxHeightMin : 1,
	boxBlingLimit : 4,
	pairedEnd : false,
	readLength : 36,
	colorBases : false,
	//storeLocal : true,
	readLimit : 5000,
  initComponent : function(){
    this.callParent(arguments);
    var self = this;

    this.absMax =-1;
    //Initialize the DOM elements
  	var containerA = new Ext.Element(document.createElement('DIV'));
  	//var containerB = new Ext.Element(document.createElement('DIV'));

  	containerA.addCls(self.clsAbove);
  	//containerB.addCls(self.clsBelow);

  	//Force some styles
  	containerA.setStyle('position', 'relative');
  	containerA.setStyle('height', '100%');
  	//containerB.setStyle('position', 'relative');
  	containerA.setStyle('width', '100%');
  	//containerB.setStyle('width', '100%');

    // if (self.single)
    // {
    //  containerA.setStyle('height', self.Canvas.ext.getHeight());
    //  containerB.setStyle('display', 'none');
    // }
    // else
    // {
    //  containerA.setStyle('height', '49%');
    //  containerB.setStyle('height', '49%');
    //       // containerA.setStyle('borderBottom', 'dotted black 1px');
    // }

  	containerA.appendTo(self.Canvas.ext);
  	//containerB.appendTo(self.Canvas.ext);

    
    //Get the absolute max for this track
  	Ext.Ajax.request(
  	{		
  		url : self.data,
  		method : 'GET',
  		params : {
  			jrws : Ext.encode({
  				method : 'abs_max',
  				param  : {
  					experiment : self.experiment,
  					bioentry : self.bioentry
  				}
  			})
  		},	
  		success  : function(response)
  		{
  			self.absMax = parseInt(response.responseText);
  			self.refreshCanvas();
  			update_max_text();
  		},		
  	});
  	
  	var combo = Ext.create('Ext.form.field.ComboBox', {
        fieldLabel : "Read Limit",
        labelAlign : 'right',
        store: [10000,5000,1000,500,100],
        displayField: 'state',
        typeAhead: true,
        queryMode: 'local',
        triggerAction: 'all',
        selectOnFocus: true,
        labelWidth:75,
        width:150,
        editable: false,
        value: self.readLimit,
        iconCls: 'no-icon',
        listeners:{
          scope: self,
          'select': function(combo,records,opts){
            this.readLimit = records[0].data.field1;
            this.refresh();
          }
        }
    });
    
  	self.colorBasesCheck = Ext.create('Ext.form.field.Checkbox', {
  	  fieldLabel : "Color Bases",
      labelAlign : 'right',
      name : 'colorBasesFlag',
      value : self.colorBases,
      labelWidth : 75,
      listeners:{
        scope: self,
        'change': function(checkbox,newVal,oldVal,opts){
          this.colorBases = newVal;
          this.refresh();
        }
      }
  	});
  	
    //add Max and Scale info to the toolbar
    var scale_text = new Ext.Toolbar.TextItem({text:"Scale:",hidden: !self.Toolbar.isVisible(),});
    var abs_max_text = new Ext.Toolbar.TextItem({text:"",hidden: !self.Toolbar.isVisible(),});
    
    //update toolbar text
    function update_max_text(){
  	  abs_max_text.setText("Max Depth: "+self.absMax);
  	}
  	
  	self.Toolbar.insert(4,scale_text);
  	self.Toolbar.insert(4,abs_max_text);
    //self.Toolbar.insert(4,combo);
    //self.Toolbar.insert(4,self.colorBasesCheck);
  	
  	//Histogram mode
    var Histogram = (function()
    {
     var dataA = new HistogramData();
     var scaler = self.scaler;
     function parse(data)
     {
       // for (var series in data)
       // {
       //   addLabel(series);
       // }       
       dataA.parse(data,true);
     };
    
     var canvasA = new Sv.painters.HistogramCanvas();

     canvasA.setColor(self.color_above);
     canvasA.setContainer(containerA.dom);
     
     canvasA.flipY();
     
     function paint(left, right, bases, pixels)
     {
       var subsetA = dataA.subset2canvas(left, right, bases, pixels);    
       canvasA.setData(subsetA);
       canvasA.paint();
     };
    
    function getScaler(){
      return self.scale
    };
    function setScaler(s){
      self.scale =s;
      canvasA.setScaler(self.scale);
    };
    this.rescale = function(f)
    {
      setScaler(Math.pow(f*2, 4));
  		var f = getScaler();
  		canvasA.refresh();
  		scale_text.setText("Scale: "+f.toFixed(2)+" x");
    };
    this.clearCanvas = function()
    {
      canvasA.clear();
    };
  	this.refreshCanvas = function()
  	{
  	  canvasA.refresh(true);
  	};
  	this.resizeCanvas = function()
  	{
  	  canvasA.refresh(true);
  	};
  	this.clearData = function()
  	{
  	  dataA.clear();
  	};
  	this.pruneData = function(a,b)
  	{
  	  dataA.prune(a,b);
  	};
  	this.setAbsMax = function(m)
  	{
  	  canvasA.setAbsMax(m);
  	};
     return {
       dataA : dataA,
       canvasA : canvasA,
       parse : parse,
       paint : paint,
       getScaler : getScaler,
       setScaler : setScaler,
 			 rescale : this.rescale,
 			 clearCanvas : this.clearCanvas,
 			 refreshCanvas : this.refreshCanvas,
 			 resizeCanvas : this.resizeCanvas,
 			 clearData : this.clearData,
 			 pruneData : this.pruneData,
 			 setAbsMax : this.setAbsMax
     };
    })();
    
  	//Reads mode
  	var Reads = (function()
  	{
  		var dataA = new ReadsList();
  		//var dataB = new ReadsList();
  		//var dataC = new HistogramData();
      var scaler = self.readSlider;

  		var canvasA = new Sv.painters.ReadsCanvas({
  			scaler : self.readSlider,
  			boxHeight : self.boxHeight,
  			boxHeightMax : self.boxHeightMax,
  			boxHeightMin : self.boxHeightMin,
  			boxBlingLimit : self.boxBlingLimit,
  			pairedEnd : self.pairedEnd,
  			colorBases : self.colorBases
  		});
      // var canvasB = new Sv.painters.ReadsCanvas({
      //  scaler : self.readSlider,
      //  boxHeight : self.boxHeight,
      //  boxHeightMax : self.boxHeightMax,
      //  boxHeightMin : self.boxHeightMin,
      //  boxBlingLimit : self.boxBlingLimit,
      //  pairedEnd : self.pairedEnd
      // });
  		//var canvasC = new Sv.painters.HistogramCanvas();
  		function parse(data, x1, x2)
  		{
        // for (var series in data)
        // {
        //  addLabel(series);
        // }
  			var msg = dataA.parse(data);
  			//dataB.parse(data,false,self.pairedEnd,self.readLength);
  			dataA.levelize();
  			
  			//dataB.levelize();
  			
        // if(msg){
        //   notifier.setText(msg);
        //   notifier.show();
        // }else{
        //   notifier.hide();
        // }
  			
  			canvasA.addBreak(x1,x2,msg);
  			//canvasB.addBreak(x1,x2,"");
  		};
  		
  		canvasA.flipY();
      canvasA.setContainer(containerA.dom);
      //canvasB.setContainer(containerB.dom);
      //canvasC.setContainer(containerC.dom);
      
  		function paint(left, right, bases, pixels)
  		{
  			var subsetA = dataA.subset2canvas(left, right, bases, pixels);
  			//var subsetB = dataB.subset2canvas(left, right, bases, pixels);
  			canvasA.setData(subsetA);
  			//canvasB.setData(subsetB);
        
        canvasA.setViewport(left,right,bases,pixels);
        //canvasB.setViewport(left,right,bases,pixels);
  			
  			canvasA.colorBases = self.colorBases;
  			
  			canvasA.paint();
  			//canvasB.paint();
  		};
      
      function getScaler(){
        return scaler;
      };
      
      function setScaler(s){
        scaler = s;
        canvasA.setScaler(scaler);
        //canvasB.setScaler(scaler);
      }
      this.rescale = function(f)
      {
        setScaler(f);
    		var f = getScaler();
    		canvasA.refresh();
    		//canvasB.refresh();
    		//canvasC.refresh();
    		scale_text.setText("Scale: "+f.toFixed(2));
      };
      this.clearCanvas = function()
    	{
        canvasA.clear();
        //canvasB.clear();
    	};
    	this.refreshCanvas = function()
    	{
        canvasA.refresh(true);
        //canvasB.refresh(true);
        //canvasC.refresh(true)
    	};
    	this.resizeCanvas = function()
    	{
        canvasA.refresh(true);
        //canvasB.refresh(true);
        //canvasC.refresh(true);
    	};
    	this.clearData = function()
    	{
        dataA.clear();
        canvasA.clearBreaks();     
        //dataB.clear();
        //canvasB.clearBreaks();
        //dataC.clear();
    	};
    	this.pruneData = function(a,b)
    	{
        dataA.prune(a,b);
        //dataB.prune(a,b);
        //dataC.prune(a,b);
    	};
  		return {
  			dataA : dataA,
  			//dataB : dataB,
  			//dataC : dataC,
  			canvasA : canvasA,
  			//canvasB : canvasB,
  			//canvasC : canvasC,
  			parse : parse,
  			paint : paint,
  			getScaler : getScaler,
  			setScaler : setScaler,
  			clearCanvas : this.clearCanvas,
  			rescale : this.rescale,
  			refreshCanvas : this.refreshCanvas,
  			resizeCanvas : this.resizeCanvas,
  			clearData : this.clearData,
  			pruneData : this.pruneData
  		};
  	})();

  	//Data handling and rendering object
  	var handler = Histogram;

  	//Zoom policies (dictate which handler to use)
  	var policies = [
  		{ index:0, min:1/100 , max:1/1    , bases:1   , pixels:100, cache:1000     },
  		{ index:1, min:1/1   , max:10/1   , bases:1   , pixels:1  , cache:10000    },
      { index:2, min:10/1  , max:100/1  , bases:10  , pixels:1  , cache:100000   },
      { index:3, min:100/1 , max:1000/1 , bases:100 , pixels:1  , cache:1000000  },
      { index:4, min:1000/1, max:10000/1, bases:1000, pixels:1  , cache:10000000 },
      { index:4, min:10000/1, max:100000/1, bases:10000, pixels:1  , cache:10000000 }
  	];

  	//Data series labels
  	var labels = null;

  	//Add series name to context menu (checkbox controls series visibility)
  	function addLabel(name)
  	{
  		if (!labels)
  		{
  			self.contextMenu.addItems(['-','Series']);
  			labels = {};
  		}

  		if (labels[name] == undefined)
  		{
  			labels[name] = true;

  			self.contextMenu.addItems([
  				new Ext.menu.CheckItem(
  				{
  					text    : name,
  					checked : true,
  					handler : function()
  					{
  						handler.canvasA.groups.toggle(name, !this.checked);
  						handler.canvasB.groups.toggle(name, !this.checked);
  						handler.canvasA.refresh();
  						handler.canvasB.refresh();
  					}
  				})
  			]);
  		}
  	};	

  	this.getPolicy = function(view)
  	{
  		var ratio = view.bases / view.pixels;

      handler.canvasA.setContainer(null);
      // handler.canvasB.setContainer(null);
        //       self.colorBasesCheck.hide();
        //       if(ratio < 10){
        //         handler = Reads;
        //         containerA.setStyle('height', '100%');
        //         containerB.setStyle('height', '0%');
        //         console.log("bases: "+view.bases+" pixels: "+view.pixels)
        //         if(view.pixels>1){
        //          self.colorBasesCheck.show(); 
        //         }
        //        //containerB.setStyle('height', '50%');
        //        //containerA.setStyle('borderBottom', 'dotted black 1px');
        //       }
        //       else{
        //         handler = Histogram;
        handler.setAbsMax(self.absMax);
        // containerA.setStyle('height', '100%');
        //         // containerA.setStyle('borderBottom', 'none');
        // containerB.setStyle('height', '0%');     
        //       }
      // 
      handler.canvasA.setContainer(containerA.dom);
      // handler.canvasB.setContainer(containerB.dom);
  		scale_text.setText("Scale: "+handler.getScaler())
  		for (var i=0; i<policies.length; i++)
  		{
  			if (ratio >= policies[i].min && ratio < policies[i].max)
  			{			
  				return policies[i];
  			}
  		}
  		return null;
  	};
  	this.rescale = function(f)
  	{
  	  handler.rescale(f);
  	};
  	this.clearCanvas = function()
  	{
  		handler.clearCanvas();
  	};
  	this.paintCanvas = function(l,r,b,p)
  	{
  		handler.paint(l,r,b,p);
  	};
  	this.refreshCanvas = function()
  	{
  	  handler.refreshCanvas();
  	};
  	this.resizeCanvas = function()
  	{
  	  handler.refresh();
  	};
  	this.clearData = function()
  	{
  	  handler.clearData();
  	};
  	this.pruneData = function(a,b)
  	{
  	  handler.pruneData(a,b);
  	};
  	this.parseData = function(data, x1, x2)
  	{
  		handler.parse(data, x1, x2);
  	};
  	this.requestReads = function(frame,pos,policy){
  	  Ext.Ajax.request({
          url: self.data,
          method: 'GET',
          params: {
              jrws: Ext.encode({
                  method: 'reads',
                  param: {
                      id: self.id,
                      experiment: self.experiment,
                      left: pos.left,
                      right: pos.right,
                      bases: policy.bases,
                      pixels: policy.pixels,
                      bioentry: self.bioentry,
                      read_limit : self.readLimit
                  }
              })
          },
          success: function(response)
          {
              response = Ext.JSON.decode(response.responseText);
              self.DataManager.parse(response.data, frame);
              self.DataManager.views.loading = null;
              self.DataManager.state.busy = false;
              self.setTitle(self.name);
              self.DataManager.setLocation(self.DataManager.views.requested);
          },
          failure: function(message)
          {
              console.error('Failed to load data for track ' + self.name + ' (' + message + ')');
              self.DataManager.views.loading = null;
              self.DataManager.state.busy = false;
              self.setTitle(self.name);
          }
      });
  	};
  }
});
