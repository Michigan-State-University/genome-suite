/*
 * The reads track shows short reads generated by high-throughput sequencing
 */
Ext.define("Sv.tracks.ReadsTrack",{
  extend : "Sv.tracks.BrowserTrack",
  clsAbove  : 'AJ_above',
  clsBelow  : 'AJ_below',
  hist_color: 'A00608',
  maxHeight : 5000,
  boxHeight : 12,
  boxHeightMax : 24,
  boxHeightMin : 1,
  boxBlingLimit : 4,
  pairedEnd : false,
  readLength : 36,
  readLimit : 1000,
  scale : 1,
  initComponent : function(){
    this.callParent(arguments);
    var self = this;
    self.addEvents({
      'viewMaxChanged' : true,
      'trackMaxChanged': true
    });
    this.trackMax=1;
    this.allTrackMax=2;
    this.viewMax = 3;
    this.allViewMax=4;
    this.scaleSource = -4;
    
    //Initialize the DOM elements
    var containerA = new Ext.Element(document.createElement('DIV'));
    containerA.addCls(self.clsAbove);
    containerA.setStyle('position', 'relative');
    containerA.setStyle('height', '100%');
    containerA.setStyle('width', '100%');
    containerA.appendTo(self.Canvas.ext);
    
    // //Lookup all max values and set any changes
    // this.updateMaxValues=function(left,right){
    //   // All Track or Global
    //   //self.setAllTrackMax(AnnoJ.getGlobalMax());
    //   // All View or Regional
    //   self.setAllViewMax(AnnoJ.getLocalMax());
    //   // This View
    //   self.setViewMax(handler.dataA.getMaxY(left,right));
    // }
    this.getViewMax = function(location){
      var edges = self.DataManager.getEdges()
      if(handler==Histogram){
        var newMax = parseInt(handler.dataA.getMaxY(edges.g1,edges.g2))
        self.setViewMax(newMax);
        //console.log(self.name+": set viewmax:"+newMax);
        return newMax;
      }else{
        return 0;
      }
    }
    //get the max that we will use to draw
    this.getCurrentMax=function(left,right){
      if(handler==Histogram){
        var newScale = 1;
        switch(self.scaleSource)
        {
        // case -1:
        //   newScale = self.trackMax;
        //   break;
        // case -2:
        //   newScale = self.allTrackMax;
        //   break;
        case -3:
          newScale = self.viewMax;
          break;
        case -4:
          newScale = self.allViewMax;
          break;
        default:
          newScale = self.scaleSource;
        }
        return newScale;
      }
    }
    
    // this.setTrackMax = function(newMax){
    //   if(newMax!=self.trackMax){
    //     self.trackMax = newMax;
    //     self.fireEvent('trackMaxChanged',newMax);
    //     self.scales.getById(1).set('name','This Track ('+newMax+')');
    //     if(self.scaleSource==-1){
    //       self.scaleSourceSelect.setValue(-1);
    //     }
    //   }
    // }
    // this.setAllTrackMax = function(newMax){
    //   if(newMax!=self.allTrackMax){
    //     self.allTrackMax = newMax;
    //     self.scales.getById(2).set('name','All Tracks ('+newMax+')');
    //     if(self.scaleSource==-2){
    //       self.scaleSourceSelect.setValue(-2);
    //     }
    //   }
    // }
    this.setViewMax = function(newMax){
      if(handler==Histogram){
        self.viewMax = newMax;
        self.scales.getById(3).set('name','This Track ('+newMax+')');
        if(self.scaleSource==-3){
          self.scaleSourceSelect.setRawValue('This Track ('+newMax+')');
        }
      }
    }
    this.setAllViewMax = function(newMax){
      if(handler==Histogram){
        self.allViewMax = newMax;
        self.scales.getById(4).set('name','All Tracks ('+newMax+')');
        if(self.scaleSource==-4){
          self.scaleSourceSelect.setRawValue('All Tracks ('+newMax+')');
        }
      }
    }
    
    // Setup the scale select list
    this.scales = Ext.create('Ext.data.Store', {
        fields: ['id', 'name', 'val'],
        data : [
            // {"id":1,"name":"This Track","val":-1},
            // {"id":2,"name":"All Tracks","val":-2},
            {"id":3,"name":"This Track","val":-3},
            {"id":4,"name":"All Tracks","val":-4}
        ]
    });
    this.scaleSourceSelect = Ext.create('Ext.form.field.ComboBox', {
      fieldLabel : "Y Scale",
      labelAlign : 'right',
      store: self.scales,
      labelWidth:75,
      width:200,
      editable: true,
      queryMode: 'local',
      displayField : 'name',
      valueField : 'val',
      listeners:{
        scope: self,
        'change': function( combo, newValue, oldValue, eOpts) {
          self.scaleSource = newValue;
          self.refresh();
          // TODO: change 'selected' to none if numbers are manually entered
        }
        
      }
    });
    
    this.lookupItem = function(id,pos){
      box = AnnoJ.getGUI().InfoBox;
      box.show();
      box.expand();
      box.echo("<div class='waiting'>Loading...</div>");
      box.setTitle("Read: "+id);
      Ext.Ajax.request({
        url         : self.data,
        method      : 'GET',
        requestJSON : false,
        params : {
          jrws : Ext.encode({
            method  : 'describe',
            param   : {
              id : id,
              bioentry : self.bioentry,
              experiment : self.experiment,
              pos : pos
            }
          })
        },
        success  : function(response){
          if (response.status == 200){
            var response_data = response.data;
            box.echo(response.responseText);
          }
          else{
            box.echo("error:"+response.responseText);
          }
        },
        failure  : function(message){
          box.echo("Error: failed to retrieve gene information:<br/>"+message);
        }
      });
    };
    
    var readLimitSelect = Ext.create('Ext.form.field.ComboBox', {
        fieldLabel : "Read Limit",
        labelAlign : 'right',
        hidden  : true,
        store: [10000,5000,1000,500,100],
        displayField: 'state',
        typeAhead: true,
        queryMode: 'local',
        triggerAction: 'all',
        selectOnFocus: true,
        labelWidth:75,
        width:150,
        editable: false,
        value: self.readLimit,
        iconCls: 'no-icon',
        keep_hidden : true,
        listeners:{
          scope: self,
          'select': function(combo,records,opts){
            self.clearData();
            self.readLimit = records[0].data.field1;
            self.refresh();
          }
        }
    });
    
    var colorBasesCheck = Ext.create('Ext.form.field.Checkbox', {
      fieldLabel : "Color Bases",
      labelAlign : 'right',
      hidden : true,
      name : 'colorBasesFlag',
      value : self.colorBases,
      keep_hidden : true,
      labelWidth : 75,
      listeners:{
        scope: self,
        'change': function(checkbox,newVal,oldVal,opts){
          self.colorBases = newVal;
          self.refresh();
        }
      }
    });

    //add Max and Scale info to the toolbar
    var multiplierText = new Ext.Toolbar.TextItem({text:"1x",hidden: !self.Toolbar.isVisible(),});
    //Handler toggle button
    var toggleReadsBtn = Ext.create('Ext.button.Button',{
      iconCls: "sequence_track",
      tooltip: "Show Aligned Sequence",
      listeners : {
        click : {
          fn : function(){
            if (!this.pressed){
              this.toggle();
              toggleHistBtn.toggle();
              handler = Reads;
              self.handler = Reads;
              readLimitSelect.show();
              readLimitSelect.keep_hidden =false
              colorBasesCheck.show();
              colorBasesCheck.keep_hidden =false
              self.scaleSourceSelect.hide()
              self.scaleSourceSelect.keep_hidden =false
              self.refresh();
              self.setLocation(AnnoJ.getLocation);
            }
          }
        }
      }
    });
    var toggleHistBtn = Ext.create('Ext.button.Button',{
      iconCls: "silk_histogram",
      tooltip: "Show Read Depth",
      pressed: true,
      listeners : {
        click : {
          fn : function(){
            if (!this.pressed){
              this.toggle();
              toggleReadsBtn.toggle();
              handler = Histogram;
              self.handler = Histogram;
              readLimitSelect.hide();
              readLimitSelect.keep_hidden =true
              colorBasesCheck.hide();
              colorBasesCheck.keep_hidden =true
              self.scaleSourceSelect.show()
              self.scaleSourceSelect.keep_hidden =true
              // Update any possible max value changes
              self.refresh();
              self.setLocation(AnnoJ.getLocation);
            }
          }
        }
      }
    });
    
    self.Toolbar.insert(4,Ext.create('Ext.toolbar.Separator'));
    self.Toolbar.insert(4,toggleReadsBtn);
    self.Toolbar.insert(4,toggleHistBtn);
    self.Toolbar.insert(4,Ext.create('Ext.toolbar.Separator'));
    self.Toolbar.insert(4,multiplierText);
    self.Toolbar.insert(4,Ext.create('Ext.toolbar.Separator'));
    self.Toolbar.insert(4,self.scaleSourceSelect);
    self.Toolbar.insert(4,readLimitSelect);
    self.Toolbar.insert(4,colorBasesCheck);
    
    
    //Histogram mode
    var Histogram = (function()
    {
     var dataA = new HistogramData();
     function parse(data)
     {      
       dataA.parse(data,true);
     };
    
     var canvasA = new Sv.painters.HistogramCanvas();
     canvasA.setColor(self.hist_color);
     canvasA.setContainer(containerA.dom);    
     canvasA.flipY();
     
     function paint(left, right, bases, pixels)
     {
       var subsetA = dataA.subset2canvas(left, right, bases, pixels);
       canvasA.setData(subsetA);
       canvasA.paint();
     };
    
    function getScaler(){
      return self.scale
    };
    function setScaler(s){
      var newVal = (s*20)-10 //-10 .. 10
      if(newVal==0) newVal=1; //-10 .. 1 .. 10
      if(newVal<0){
        newVal = 1/(0-newVal) //0.1 .. 1 .. 10
      }
      self.scale = newVal;
      canvasA.setScaler(newVal);
    };
    this.rescale = function(f)
    {
      setScaler(f);
      var f = getScaler();
      canvasA.refresh();
      self.setMultiplierText(f.toFixed(2));
    };
    
    this.clearCanvas = function()
    {
      canvasA.clear();
    };
    this.refreshCanvas = function()
    {
      canvasA.refresh(true);
    };
    this.resizeCanvas = function()
    {
      canvasA.refresh(true);
    };
    this.clearData = function()
    {
      dataA.clear();
    };
    this.pruneData = function(a,b)
    {
      dataA.prune(a,b);
    };
    this.setAbsMax = function(m)
    {
      canvasA.setAbsMax(m);
    };
     return {
       dataA : dataA,
       canvasA : canvasA,
       parse : parse,
       paint : paint,
       getScaler : getScaler,
       setScaler : setScaler,
       rescale : this.rescale,
       clearCanvas : this.clearCanvas,
       refreshCanvas : this.refreshCanvas,
       resizeCanvas : this.resizeCanvas,
       clearData : this.clearData,
       pruneData : this.pruneData,
       setAbsMax : this.setAbsMax,
       method : 'range'
     };
    })();
    
    //Reads mode
    var Reads = (function()
    {
      var dataA = new ReadsList();
      var myScaler = 0.75;
      var canvasA = new Sv.painters.ReadsCanvas({
        scaler : 0.75,
        boxHeight : self.boxHeight,
        boxHeightMax : self.boxHeightMax,
        boxHeightMin : self.boxHeightMin,
        boxBlingLimit : self.boxBlingLimit,
        pairedEnd : self.pairedEnd,
        colorBases : self.colorBases
      });
      
      canvasA.flipY();
      canvasA.setContainer(containerA.dom);
      canvasA.on('itemSelected', self.lookupItem);
      
      function parse(data,x1,x2)
      {
        var msg = dataA.parse(data);
        dataA.levelize();
        canvasA.addBreak(x1,x2,msg);      
      };
      
      function paint(left, right, bases, pixels)
      {
        //console.log("Paint canvas: "+canvasA.id+" track: "+self.name)
        var subsetA = dataA.subset2canvas(left, right, bases, pixels);
        canvasA.setData(subsetA);        
        canvasA.setViewport(left,right,bases,pixels);       
        canvasA.colorBases = self.colorBases;
        canvasA.paint();
      };
      function getScaler(){
        return myScaler;
      }
      function setScaler(s){
        myScaler = s
        canvasA.setScaler(s);
      }
      this.rescale = function(s)
      {
        setScaler(s);
        canvasA.refresh();
        self.setMultiplierText(s.toFixed(2));
      };
      this.clearCanvas = function(){canvasA.clear();};
      this.refreshCanvas = function(){canvasA.refresh(true);};
      this.resizeCanvas = function(){canvasA.refresh(true);};
      this.clearData = function(){dataA.clear();canvasA.clearBreaks();};
      this.pruneData = function(a,b){dataA.prune(a,b);};
      this.setAbsMax = function(){};
      return {
        dataA : dataA,
        canvasA : canvasA,
        parse : parse,
        paint : paint,
        getScaler : getScaler,
        setScaler : setScaler,
        clearCanvas : this.clearCanvas,
        rescale : this.rescale,
        refreshCanvas : this.refreshCanvas,
        resizeCanvas : this.resizeCanvas,
        clearData : this.clearData,
        pruneData : this.pruneData,
        setAbsMax : setAbsMax,
        method : 'reads'
      };
    })();
    
    //Data handling and rendering object
    var handler = Histogram;
    this.handler = handler;
    
    //Change the color(s) for this track
  	this.setColor = function(color,type){
      self.hist_color = color;
      switch (type){
        case 'hist': Histogram.canvasA.setColor(color); break;
        case 'forward': Reads.canvasA.setForwardColor(color); break;
        case 'reverse': Reads.canvasA.setReverseColor(color); break;
      }
      handler.canvasA.refresh();
  	};
  	//Add the color menu
    var addColorMenu = function(menuText, type){
        self.contextMenu.ext.add(
         {
             iconCls: 'silk_palette',
             text: menuText,
             menu: {
                     xtype: 'colormenu',
                     handler: function(colorMenu, color){
                         self.setColor(color, type);
                     },
                     height: 75,
                     colors: self.color_values
             }
         });
    };
    addColorMenu("Histogram", 'hist');
  	addColorMenu("Forward Reads", 'forward');
		addColorMenu("Reverse Reads", 'reverse');
		
    //Zoom policies (dictate which handler to use)
    var policies = [
      { index:0, min:1/100 , max:1/1    , bases:1   , pixels:100, cache:1000     },
      { index:1, min:1/1   , max:10/1   , bases:1   , pixels:1  , cache:10000    },
      { index:2, min:10/1  , max:100/1  , bases:10  , pixels:1  , cache:100000   },
      { index:3, min:100/1 , max:1000/1 , bases:100 , pixels:1  , cache:1000000  },
      { index:4, min:1000/1, max:10000/1, bases:1000, pixels:1  , cache:10000000 },
      { index:5, min:10000/1, max:100000/1, bases:10000, pixels:1  , cache:100000000 },
    ];

    //Data series labels
    var labels = null;

    this.getPolicy = function(view)
    {
      var ratio = view.bases / view.pixels;

      handler.canvasA.setContainer(null);
      
      handler.canvasA.setContainer(containerA.dom);
      self.setMultiplierText(handler.getScaler().toFixed(2));
      for (var i=0; i<policies.length; i++)
      {
        if (ratio >= policies[i].min && ratio < policies[i].max)
        {     
          return policies[i];
        }
      }
      return null;
    };
    this.setMultiplierText = function(multiple)
    {
      if(multiple){
        multiplierText.setText(+multiple+" x");
      }else{
        multiplierText.setText("0 x");
      }
      
    };
    this.rescale = function(f)
    {
      handler.rescale(f);
    };
    this.clearCanvas = function()
    {
      handler.clearCanvas();
    };
    this.paintCanvas = function(l,r,b,p)
    {
      //Before Painting we always set the canvas absMax
      //ignored by reads
      handler.setAbsMax(self.getCurrentMax());
      handler.paint(l,r,b,p);
    };
    this.refreshCanvas = function()
    {
      handler.refreshCanvas();
    };
    this.resizeCanvas = function()
    {
      handler.refresh();
    };
    this.clearData = function()
    {
      handler.clearData();
    };
    this.pruneData = function(a,b)
    {
      handler.pruneData(a,b);
    };
    this.parseData = function(data, x1, x2)
    {
      handler.parse(data, x1, x2);
    };
    this.requestFrame = function(pos,policy,successFunc,failureFunc){
      Ext.Ajax.request({
          url: self.data,
          method: 'GET',
          params: {
              jrws: Ext.encode({
                  method: self.requestFormat(),
                  param: {
                      id: self.id,
                      experiment: self.experiment,
                      left: pos.left,
                      right: pos.right,
                      bases: policy.bases,
                      pixels: policy.pixels,
                      bioentry: self.bioentry,
                      read_limit : self.readLimit
                  }
              })
          },
          success: function(response)
          {
              response = Ext.JSON.decode(response.responseText);
              successFunc(response);
          },
          failure: function(message)
          {
            failureFunc(message);
          }
      });
    };
    
  },
  // extend open function
  open: function(){
    this.callParent();
    this.scaleSourceSelect.setValue(this.scaleSource);
  },

  localStoreId: function(){
    var self = this;
    if(self.handler.method == 'reads'){
      return self.readLimit;
    }else{
      return this.callParent();
    }
  },
  requestFormat: function(){
    return this.handler.method;
  }
});
