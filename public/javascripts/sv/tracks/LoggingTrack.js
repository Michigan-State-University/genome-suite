/*
 * The reads track shows short reads generated by high-throughput sequencing.
 * The display is rendered at three levels, histogram, boxes and sequence
 * This is slightly different from the stacks track which collapses reads
 */
AnnoJ.LoggingTrack = function(userConfig)
{
	var self = this;
	
	AnnoJ.LoggingTrack.superclass.constructor.call(self, userConfig);

	var defaultConfig = {
		single    : true,
		clsAbove  : 'AJ_above',
    clsBelow  : 'AJ_below',
		slider    : 0.5,
		boxHeight : 10,
		boxHeightMax : 24,
		boxHeightMin : 1,
		boxBlingLimit : 6,
		pairedEnd : false,
		readLength : 36
	};
	Ext.applyIf(self.config, defaultConfig);
	
	//Initialize the DOM elements
	var containerA = new Ext.Element(document.createElement('DIV'));
	
	containerA.addCls(self.config.clsAbove);
	
	//Force some styles
	containerA.setStyle('position', 'relative');
	containerA.setStyle('width', '100%');
	containerA.setStyle('margin-bottom','20px')
		
	if (self.config.single)
	{
		containerA.setStyle('height', self.Canvas.ext.getHeight());
	}
	else
	{
		containerA.setStyle('height', '49%');
		containerA.setStyle('borderBottom', 'dotted black 1px');
	}

	containerA.appendTo(self.Canvas.ext);

	
		
	//Grid mode
	var Grid = (function()
	{
    function grid(obj)
    {
      Ext.QuickTips.init();
      var xg = Ext.grid;

          var reader = new Ext.data.JsonReader({
              idProperty:'taskId',
              fields: [
                  {name: 'id', type: 'int'},
                  {name: 'user', type: 'string'},
                  {name: 'bioentry', type: 'string'},
                  {name: 'action', type: 'string'},
                  {name: 'type', type: 'string'},
                  {name: 'info', type: 'string'},
                  {name: 'changed', type: 'date', dateFormat: 'm/d/Y'}
              ],
              root:'data',
              remoteGroup:true,
              remoteSort: true
          });

          var grid = new xg.EditorGridPanel({
          	ds: new Ext.data.GroupingStore({
          	  reader: reader,
          				// use remote data
              proxy : new Ext.data.HttpProxy({
                  url: 'edits/log/1',
                  method: 'GET'

              }),
              sortInfo: {field: 'action', direction: 'ASC'},
              groupField: 'user'
          }),

           columns: [
              {
                  id: 'id',
                  header: 'Entry',
                  width: 5,
                  sortable: true,
                  dataIndex: 'id',
                  hideable: false
              },{
                  header: 'User',
                  width: 10,
                  sortable: true,
                  dataIndex: 'user'
              },{
                  header: 'Bioentry',
                  width: 10,
                  sortable: true,
                  dataIndex: 'bioentry'
              },{
                  header: 'Action',
                  width: 10,
                  sortable: true,
                  dataIndex: 'action'
              },{
                  header: 'Type',
                  width: 10,
                  sortable: true,
                  dataIndex: 'type'
              }, {
                  id: 'info',
                  header: 'Info',
                  width: 80,
                  height: 40,
                  sortable: false,
                  groupable: false,
                  dataIndex: 'info',
              }, {
                  header: 'Changed',
                  width: 40,
                  sortable: true,
                  groupable: false,
                  renderer: Ext.util.Format.dateRenderer('m/d/Y'),
                  dataIndex: 'changed'
              }
          ],

          view: new Ext.grid.GroupingView({
              forceFit:true,
              showGroupName: false,
              enableNoGroups:false,
      	      enableGroupingMenu:false,
              hideGroupedColumn: false
          }),

          frame: true,
          width: obj.getWidth(),
          height: obj.getHeight() - 18,
          clicksToEdit: 1,
          collapsible: true,
          animCollapse: false,
          trackMouseOver: false,
          iconCls: 'icon-grid',
          renderTo: obj.dom.childNodes[0].childNodes[0]
        });

        grid.on('afteredit', function(){
            var groupValue = 'Ext Forms: Field Anchoring';
        });
        grid.store.load();
      }
				
      // function parse(data)
      // {
      //  for (var series in data)
      //  {
      //    addLabel(series);
      //  }
      // };
  		
  		function refresh(obj){
  		  if(obj.dom.childNodes[0].childNodes[0].childNodes[0]){
    	    var grid = obj.dom.childNodes[0].childNodes[0].childNodes[0]
    	    var parent = grid.parentNode
    	    parent.removeChild(grid)
    	  }
  		};

      // function paint(left, right, bases, pixels)
      // {
      // 
      // };
		
    	return {
    	  grid      : grid,
    	  refresh   : refresh
    	};
    	
  	})();


	
  	//Data handling and rendering object
  	var handler = Grid;
		
  	//Zoom policies (dictate which handler to use)
  	var policies = [
  		{ index:0, min:1/100 , max:1/1    , bases:1   , pixels:100, cache:1000     },
  		{ index:1, min:1/1   , max:10/1   , bases:1   , pixels:1  , cache:10000    },
  		{ index:2, min:10/1  , max:100/1  , bases:10  , pixels:1  , cache:100000   },
  		{ index:3, min:100/1 , max:1000/1 , bases:100 , pixels:1  , cache:1000000  },
  		{ index:4, min:1000/1, max:10000/1, bases:1000, pixels:1  , cache:10000000 }
  	];
	
  	//Data series labels
  	var labels = null;
		
  	//Add series name to context menu (checkbox controls series visibility)
  	function addLabel(name)
  	{

	};	
	
	this.getPolicy = function(view)
	{
    // console.log("getPolicy")
    return policies[1]
	};
	this.rescale = function(f)
	{
    // console.log("rescaling")
	};
	this.clearCanvas = function()
	{
	  if(self.ext.dom.childNodes[0].childNodes[0].childNodes[0]){
      handler.refresh(self.ext);
    }
    
	};
	this.paintCanvas = function(l,r,b,p)
	{
    // console.log("paintCanvas");
    // handler.paint(l,r,b,p);

	};
	this.refresh = function()
	{
    if(self.ext.dom.childNodes[0].childNodes[0].childNodes[0]){
      handler.refresh(self.ext);
      self.parseData()
    }
    
	};
	this.resizeCanvas = function()
	{
    // console.log("resizeCanvas")
    // handler.canvasA.refresh(true);
    // handler.canvasB.refresh(true);
	};
	this.clearData = function()
	{
    // console.log("clearData")
    // handler.dataA.clear();
    // handler.dataB.clear();
	};
	this.pruneData = function(a,b)
	{
    // console.log("pruneData")
    // handler.dataA.prune(a,b);
    // handler.dataB.prune(a,b);
	};
	this.parseData = function(data)
	{
    // console.log("parseData")
    handler.grid(self.ext)

	};
};
Ext.extend(AnnoJ.LoggingTrack,AnnoJ.BrowserTrack,{})
