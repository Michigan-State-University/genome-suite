/*
 * The genome track shows short reads generated by high-throughput sequencing.
 * The display is rendered at one level: sequence
 */
AnnoJ.GenomeTrack = function(userConfig)
{
	var self = this;
	AnnoJ.GenomeTrack.superclass.constructor.call(self, userConfig);
	var defaultConfig = {
		single    : false,
		clsAbove  : 'AJ_above',
		clsBelow  : 'AJ_below',
		slider    : 0.5,
		boxHeight : 10,
		boxHeightMax : 24,
		boxHeightMin : 1,
		boxBlingLimit : 6,
		pairedEnd : false,
		readLength : 36
	};
	Ext.applyIf(self.config, defaultConfig);
	
	//Initialize the DOM elements
	var containerA = new Ext.Element(document.createElement('DIV'));
   var containerB = new Ext.Element(document.createElement('DIV'));
	
	containerA.addCls(self.config.clsAbove);
   containerB.addCls(self.config.clsBelow);
	
	//Force some styles
	containerA.setStyle('position', 'relative');
   containerB.setStyle('position', 'relative');
	containerA.setStyle('width', '100%');
   containerB.setStyle('width', '100%');
		
	if (self.config.single)
	{
		containerA.setStyle('height', self.Canvas.ext.getHeight());
		containerB.setStyle('display', 'none');
	}
	else
	{
		containerA.setStyle('height', '49%');
		containerB.setStyle('height', '49%');
		containerA.setStyle('borderBottom', 'dotted black 1px');
	}
  // console.log("Genome Canvas")
  // console.log(self.Canvas.ext)
	containerA.appendTo(self.Canvas.ext);
  containerB.appendTo(self.Canvas.ext);
		
	
	var Sequence = (function()
	{
    var dataA = new SequenceList();
    var dataB = new SequenceList();
	
		function parse(data)
		{
			for (var series in data)
			{
        // This may need to be enabled. Dumping because I don't understand it 
        // as of yet
        addLabel(series);
			}
			dataA.parse(data);
      	//dataB.parse(data);
		};
		
		
		  var canvasA = new SequenceCanvas({
						scaler : self.config.slider,
		  		    	boxHeight : self.config.boxHeight,
		  		    	boxHeightMax : self.config.boxHeightMax,
		  		    	boxHeightMin : self.config.boxHeightMin,
		    			boxBlingLimit : self.config.boxBlingLimit,
						pairedEnd : self.config.pairedEnd
		  		  });
		
		  // var canvasB = new SequenceCanvas({
		  // 				scaler : self.config.slider,
		  //   	boxHeight : self.config.boxHeight,
		  //   	boxHeightMax : self.config.boxHeightMax,
		  //   	boxHeightMin : self.config.boxHeightMin,
		  //   				boxBlingLimit : self.config.boxBlingLimit,
		  // 				pairedEnd : self.config.pairedEnd
		  // });
		
  		//canvasB.flipY();
		
		
		function paint(left, right, bases, pixels)
		{
		  
			var subsetA = dataA.subset2canvas(left, right, bases, pixels);
      // var subsetB = dataB.subset2canvas(left, right, bases, pixels);
      // console.log("Genome subsetA")
      // console.log(subsetA)
      canvasA.setData(subsetA);
      // canvasB.setData(subsetB);
			
			canvasA.paint();
      // canvasB.paint();

		};
		
		return {
			dataA : dataA,
      	//dataB : dataB,
			canvasA : canvasA,
      	//canvasB : canvasB,
			parse : parse,
			paint : paint
		};
	})();
	
	//Data handling and rendering object
	var handler = Sequence;
	
	//Data series labels
	var labels = null;
		
	//Add series name to context menu (checkbox controls series visibility)
	function addLabel(name)
	{
		if (!labels)
		{
			self.ContextMenu.addItems(['-','Series']);
			labels = {};
		}

		if (labels[name] == undefined)
		{
			labels[name] = true;
		
			self.ContextMenu.addItems([
				new Ext.menu.CheckItem(
				{
					text    : name,
					checked : true,
					handler : function()
					{
						handler.canvasA.groups.toggle(name, !this.checked);
						//handler.canvasB.groups.toggle(name, !this.checked);
						handler.canvasA.refresh();
						//handler.canvasB.refresh();
					}
				})
			]);
		}
	};	
	
	//Zoom policies (dictate which handler to use)
	var policies = [
		{ index:0, min: 1/20, max: 1/5, bases: 1, pixels: 5, cache: 10000, handler: 'Sequence'}
		// { index:0, min:1/100 , max:1/1    , bases:1   , pixels:100, cache:1000     },
		// { index:1, min:1/20   , max:10/20  , bases:1   , pixels:20  , cache:10000    },
		// { index:2, min:1/10   , max:10/10  , bases:1   , pixels:10  , cache:10000    },
		// { index:3, min:1/9   , max:10/9   , bases:1   , pixels:9  , cache:10000    },
		// { index:4, min:1/8   , max:10/8   , bases:1   , pixels:8  , cache:10000    },
		// { index:5, min:1/7   , max:10/7   , bases:1   , pixels:7  , cache:10000    },
		// { index:6, min:1/6   , max:10/6   , bases:1   , pixels:6  , cache:10000    },
		// { index:7, min:1/5   , max:10/5   , bases:1   , pixels:5  , cache:10000    },
		// { index:8, min:1/4   , max:10/4   , bases:1   , pixels:4  , cache:10000    },
		// { index:9, min:1/3   , max:10/3   , bases:1   , pixels:3  , cache:10000    },
		// { index:10, min:1/2   , max:10/2   , bases:1   , pixels:2  , cache:10000    },
		// { index:11, min:1/1   , max:10/1   , bases:1   , pixels:1  , cache:10000    },
		// { index:12, min:2/1  , max:20/1  , bases:2  , pixels:1  , cache:100000   },
		// { index:13, min:3/1  , max:30/1  , bases:3  , pixels:1  , cache:100000   },
		// { index:14, min:4/1  , max:40/1  , bases:4  , pixels:1  , cache:100000   },
		// { index:15, min:5/1  , max:50/1  , bases:5  , pixels:1  , cache:100000   },
		// { index:16, min:6/1  , max:60/1  , bases:6  , pixels:1  , cache:100000   },
		// { index:17, min:7/1  , max:70/1  , bases:7  , pixels:1  , cache:100000   },
		// { index:18, min:8/1  , max:80/1  , bases:8  , pixels:1  , cache:100000   },
		// { index:19, min:9/1  , max:90/1  , bases:9  , pixels:1  , cache:100000   },
		// { index:20, min:10/1  , max:100/1  , bases:10  , pixels:1  , cache:100000   },
		// { index:21, min:100/1 , max:1000/1 , bases:100 , pixels:1  , cache:1000000  },
		// { index:22, min:1000/1, max:10000/1, bases:1000, pixels:1  , cache:10000000 }
	];
	
	this.getPolicy = function(view)
	{
    var ratio = view.bases / view.pixels;

	handler.canvasA.setContainer(null);
    // handler.canvasB.setContainer(null);

    // handler.canvasB.setContainer(containerB.dom);
    handler.canvasA.setContainer(containerA.dom);
		
    for (var i=0; i<policies.length; i++)
    {
     if (ratio <= policies[i].max && ratio >= policies[i].min)
     { 

		 handler = eval(policies[i].handler)
		 handler.canvasA.setContainer(containerA.dom);
       return policies[i];
     }
    }
 	
    return null;
	};
	
	this.rescale = function(f)
	{
		handler.canvasA.setScaler(f);
    // handler.canvasB.setScaler(f);
		handler.canvasA.refresh();
    // handler.canvasB.refresh();
	};
	
	this.clearCanvas = function()
	{
		handler.canvasA.clear();
    // handler.canvasB.clear();
	};
	
	this.paintCanvas = function(l,r,b,p)
	{
		handler.paint(l,r,b,p);
	};
	
	this.refreshCanvas = function()
	{
		handler.canvasA.refresh(true);
    // handler.canvasB.refresh(true);
	};
	
	this.resizeCanvas = function()
	{
		handler.canvasA.refresh(true);
    // handler.canvasB.refresh(true);
	};
	
	this.clearData = function()
	{
		handler.dataA.clear();
    // handler.dataB.clear();
	};
	
	this.pruneData = function(a,b)
	{
		handler.dataA.prune(a,b);
    // handler.dataB.prune(a,b);
	};
	
	this.parseData = function(data)
	{
		handler.parse(data);
	};
};

Ext.extend(AnnoJ.GenomeTrack,AnnoJ.BrowserTrack,{})
